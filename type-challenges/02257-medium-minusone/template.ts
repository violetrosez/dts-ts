// 在 TypeScript 中，我们没有办法对数字类型直接进行加减等计算操作，所以能够想到的办法还是借助于数组：

// 首先把数字转换为对应长度的数组（数组元素任意，可以全部用 0 填充）；
// 然后去掉数组第一个元素；
// 最后取剩余元素的个数作为计算结果。
// 接下来以数字 13 为例，讲一讲计算的过程：

// 从左向右取出数字，首先取出 1；
// 将数字 1 转换为长度为 1 的数组 [0]；
// 将 [0] 长度扩充 10 倍，变成 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]（共 10 个 0）；
// 继续取出下一个数字 3；
// 将数字 3 转换为长度为 3 的数组 [0, 0, 0];
// 将第 3 步和第 5 步中的数组加在一起，即可得到数组 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]，对应的就是数字 13 对应长度的数组；
// 去掉数组头部的 0，得到剩余 12 个元素的数组，所以最终答案为 12。

// 你的答案
type Dict = {
    '0': [];
    '1': [0];
    '2': [0, 0];
    '3': [0, 0, 0];
    '4': [0, 0, 0, 0];
    '5': [0, 0, 0, 0, 0];
    '6': [0, 0, 0, 0, 0, 0];
    '7': [0, 0, 0, 0, 0, 0, 0];
    '8': [0, 0, 0, 0, 0, 0, 0, 0];
    '9': [0, 0, 0, 0, 0, 0, 0, 0, 0];
  }
  
  // 乘以 10 倍
  type TenTimes<A extends 0[]> = [
    ...A, ...A, ...A, ...A, ...A,
    ...A, ...A, ...A, ...A, ...A
  ]
  
  // 将数字转化为用 0 填充的数组，数字值对应数组长度
  // 例如：
  // 3 -> [0, 0, 0]
  // 11 -> [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  type ToArray<
    N extends string,
    Result extends 0[] = []
  > = N extends `${infer F extends keyof Dict}${infer R}`
    ? ToArray<R, [...TenTimes<Result>, ...Dict[F]]>
    : Result
  
  type MinusOne<
    T extends number
  > = ToArray<`${T}`> extends [infer F, ...infer R]
        ? R['length']
        : never
